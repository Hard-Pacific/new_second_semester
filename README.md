# Работа над ошибками
## Дополнительная задача. Алгоритм Хаффмана
Спроектировать в максимально объектно-ориентированном стиле и реализовать консольную утилиту, выполняющую сжатие/разжатие произвольного файла по алгоритму Хаффмана (описание которого предлагается найти самостоятельно). Утилита должна принимать два параметра:

- имя файла, который необходимо сжать или разжать;
- ключ `--compress` или `--uncompress`. Также должны поддерживаться их сокращённые формы, `-c` и `-u`, соответственно.

При получении ключа `--compress` (`-c`) программа должна создать файл с именем, соответствующем исходному, и расширением `.zipped`, куда вывести сжатое алгоритмом Хаффмана содержимое исходного файла, плюс любую дополнительную информацию, которую считаете нужной добавить для разжатия. Также должен печататься коэффициент сжатия (отношение исходной длины файла к сжатой). 
 
При получении ключа `--uncompress` (`-u`) программа должна создать файл, имя которого соответствует полученному в первом аргументе, но без расширения `.zipped`, и содержащий исходную информацию. Последовательное применение утилиты с ключами `--compress` и `--uncompress` должно возвращать файл в исходное состояние.

Обратите внимание, что сжатию могут подвергаться произвольные бинарные файлы.

## BWT
Реализовать преобразование Барроуза-Уилера. На вход подаётся строка, на выходе должна получиться строка, преобразованная Барроузом-Уилером, и позиция конца строки в результате преобразования. Реализовать также и обратное преобразование, принимающее преобразованную строку и позицию, и возвращающую исходную строку. Проверить, что исходная строка действительно восстанавливается.

+1 балл за решение, где в прямом преобразовании не строится явно таблица вращений строк;
+1 балл за решение, где в обратном преобразовании используется построение циклической перестановки, без явного построения таблицы.
Подумайте, как представлять вращение строки без лишних строк.

Задача оценивается в 4 балла, плюс возможность получить два дополнительных.

## Бор
Реализовать в виде класса структуру данных "Бор" (http://neerc.ifmo.ru/wiki/index.php?title=%D0%91%D0%BE%D1%80)

Должны быть поддержаны следующие методы:

bool Add(string element) (возвращает true, если такой строки ещё не было, работает за O(|element|))
bool Contains(string element) (работает за O(|element|))
bool Remove(string element) (возвращает true, если элемент реально был в дереве, работает за O(|element|))
int HowManyStartsWithPrefix(String prefix) (работает за O(|prefix|))
И свойство

int Size (работает за O(1))

## Дерево разбора
Решить задачу о вычислении выражения по дереву разбора из прошлого семестра. Реализовать иерархию классов, описывающих дерево разбора, используя их, реализовать класс, вычисляющий значение выражения по дереву. Классы, представляющие операнды и операторы, должны сами уметь себя вычислять и печатать. Входной файл может быть некорректен, необходимо использовать исключения для сигнализации об ошибках (и тестировать, что они действительно бросаются).

Исходное условие:

По дереву разбора арифметического выражения вычислить его значение. Дерево разбора хранится в файле в виде (<операция> <операнд1> <операнд2>), где <операнд1> и <операнд2> сами могут быть деревьями, либо числами. Например, выражение (1 + 1) * 2 представляется в виде (* (+ 1 1) 2). Должны поддерживаться операции +, -, *, / и целые числа в качестве аргументов. Требуется построить дерево в явном виде, распечатать его (не обязательно так же, как в файле), и посчитать значение выражения обходом дерева. Пример — по входному файлу (* (+ 1 1) 2) может печататься ( * ( + 1 1 ) 2 ) и выводиться 4.
